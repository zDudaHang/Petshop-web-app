{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport removeAccents from 'remove-accents';\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 9,\n  EQUAL: 8,\n  STARTS_WITH: 7,\n  WORD_STARTS_WITH: 6,\n  STRING_CASE: 5,\n  STRING_CASE_ACRONYM: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nvar caseRankings = {\n  CAMEL: 0.8,\n  PASCAL: 0.6,\n  KEBAB: 0.4,\n  SNAKE: 0.2,\n  NO_CASE: 0\n};\nmatchSorter.rankings = rankings;\nmatchSorter.caseRankings = caseRankings;\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\n\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  } // not performing any search/sort if value(search term) is empty\n\n\n  if (!value) return items;\n  var _options = options,\n      keys = _options.keys,\n      _options$threshold = _options.threshold,\n      threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold;\n  var matchedItems = items.reduce(reduceItemsToRanked, []);\n  return matchedItems.sort(sortRankedItems).map(function (_ref) {\n    var item = _ref.item;\n    return item;\n  });\n\n  function reduceItemsToRanked(matches, item, index) {\n    var _getHighestRanking = getHighestRanking(item, keys, value, options),\n        rankedItem = _getHighestRanking.rankedItem,\n        rank = _getHighestRanking.rank,\n        keyIndex = _getHighestRanking.keyIndex,\n        _getHighestRanking$ke = _getHighestRanking.keyThreshold,\n        keyThreshold = _getHighestRanking$ke === void 0 ? threshold : _getHighestRanking$ke;\n\n    if (rank >= keyThreshold) {\n      matches.push({\n        rankedItem: rankedItem,\n        item: item,\n        rank: rank,\n        index: index,\n        keyIndex: keyIndex\n      });\n    }\n\n    return matches;\n  }\n}\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\n\n\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedItem: item,\n      rank: getMatchRanking(item, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n\n  var valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce(function (_ref2, _ref3, i) {\n    var rank = _ref2.rank,\n        rankedItem = _ref2.rankedItem,\n        keyIndex = _ref2.keyIndex,\n        keyThreshold = _ref2.keyThreshold;\n    var itemValue = _ref3.itemValue,\n        attributes = _ref3.attributes;\n    var newRank = getMatchRanking(itemValue, value, options);\n    var newRankedItem = rankedItem;\n    var minRanking = attributes.minRanking,\n        maxRanking = attributes.maxRanking,\n        threshold = attributes.threshold;\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedItem = itemValue;\n    }\n\n    return {\n      rankedItem: newRankedItem,\n      rank: rank,\n      keyIndex: keyIndex,\n      keyThreshold: keyThreshold\n    };\n  }, {\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\n\n\nfunction getMatchRanking(testString, stringToRank, options) {\n  /* eslint complexity:[2, 12] */\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options); // too long\n\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  } // case sensitive equals\n\n\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n\n  var caseRank = getCaseRanking(testString);\n  var isPartial = isPartialOfCase(testString, stringToRank, caseRank);\n  var isCasedAcronym = isCaseAcronym(testString, stringToRank, caseRank); // Lower casing before further comparison\n\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase(); // case insensitive equals\n\n  if (testString === stringToRank) {\n    return rankings.EQUAL + caseRank;\n  } // starts with\n\n\n  if (testString.indexOf(stringToRank) === 0) {\n    return rankings.STARTS_WITH + caseRank;\n  } // word starts with\n\n\n  if (testString.indexOf(\" \" + stringToRank) !== -1) {\n    return rankings.WORD_STARTS_WITH + caseRank;\n  } // is a part inside a cased string\n\n\n  if (isPartial) {\n    return rankings.STRING_CASE + caseRank;\n  } // is acronym for a cased string\n\n\n  if (caseRank > 0 && isCasedAcronym) {\n    return rankings.STRING_CASE_ACRONYM + caseRank;\n  } // contains\n\n\n  if (testString.indexOf(stringToRank) !== -1) {\n    return rankings.CONTAINS + caseRank;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  } // acronym\n\n\n  if (getAcronym(testString).indexOf(stringToRank) !== -1) {\n    return rankings.ACRONYM + caseRank;\n  } // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n\n\n  return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\n\n\nfunction getAcronym(string) {\n  var acronym = '';\n  var wordsInString = string.split(' ');\n  wordsInString.forEach(function (wordInString) {\n    var splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(function (splitByHyphenWord) {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n/**\n * Returns a score base on the case of the testString\n * @param {String} testString - the string to test against\n * @returns {Number} the number of the ranking,\n * based on the case between 0 and 1 for how the testString matches the case\n */\n\n\nfunction getCaseRanking(testString) {\n  var containsUpperCase = testString.toLowerCase() !== testString;\n  var containsDash = testString.indexOf('-') >= 0;\n  var containsUnderscore = testString.indexOf('_') >= 0;\n\n  if (!containsUpperCase && !containsUnderscore && containsDash) {\n    return caseRankings.KEBAB;\n  }\n\n  if (!containsUpperCase && containsUnderscore && !containsDash) {\n    return caseRankings.SNAKE;\n  }\n\n  if (containsUpperCase && !containsDash && !containsUnderscore) {\n    var startsWithUpperCase = testString[0].toUpperCase() === testString[0];\n\n    if (startsWithUpperCase) {\n      return caseRankings.PASCAL;\n    }\n\n    return caseRankings.CAMEL;\n  }\n\n  return caseRankings.NO_CASE;\n}\n/**\n * Returns whether the stringToRank is one of the case parts in the testString (works with any string case)\n * @example\n * // returns true\n * isPartialOfCase('helloWorld', 'world', caseRankings.CAMEL)\n * @example\n * // returns false\n * isPartialOfCase('helloWorld', 'oworl', caseRankings.CAMEL)\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Number} caseRanking - the ranking score based on case of testString\n * @returns {Boolean} whether the stringToRank is one of the case parts in the testString\n */\n\n\nfunction isPartialOfCase(testString, stringToRank, caseRanking) {\n  var testIndex = testString.toLowerCase().indexOf(stringToRank.toLowerCase());\n\n  switch (caseRanking) {\n    case caseRankings.SNAKE:\n      return testString[testIndex - 1] === '_';\n\n    case caseRankings.KEBAB:\n      return testString[testIndex - 1] === '-';\n\n    case caseRankings.PASCAL:\n    case caseRankings.CAMEL:\n      return testIndex !== -1 && testString[testIndex] === testString[testIndex].toUpperCase();\n\n    default:\n      return false;\n  }\n}\n/**\n * Check if stringToRank is an acronym for a partial case\n * @example\n * // returns true\n * isCaseAcronym('super_duper_file', 'sdf', caseRankings.SNAKE)\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the acronym to test\n * @param {Number} caseRank - the ranking of the case\n * @returns {Boolean} whether the stringToRank is an acronym for the testString\n */\n\n\nfunction isCaseAcronym(testString, stringToRank, caseRank) {\n  var splitValue = null;\n\n  switch (caseRank) {\n    case caseRankings.SNAKE:\n      splitValue = '_';\n      break;\n\n    case caseRankings.KEBAB:\n      splitValue = '-';\n      break;\n\n    case caseRankings.PASCAL:\n    case caseRankings.CAMEL:\n      splitValue = /(?=[A-Z])/;\n      break;\n\n    default:\n      splitValue = null;\n  }\n\n  var splitTestString = testString.split(splitValue);\n  return stringToRank.toLowerCase().split('').reduce(function (correct, char, charIndex) {\n    var splitItem = splitTestString[charIndex];\n    return correct && splitItem && splitItem[0].toLowerCase() === char;\n  }, true);\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\n\n\nfunction getClosenessRanking(testString, stringToRank) {\n  var matchingInOrderCharCount = 0;\n  var charNumber = 0;\n\n  function findMatchingCharacter(matchChar, string, index) {\n    for (var j = index; j < string.length; j++) {\n      var stringChar = string[j];\n\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n\n    return -1;\n  }\n\n  function getRanking(spread) {\n    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    var ranking = rankings.MATCHES + inOrderPercentage * (1 / spread);\n    return ranking;\n  }\n\n  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n\n  charNumber = firstIndex;\n\n  for (var i = 1; i < stringToRank.length; i++) {\n    var matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    var found = charNumber > -1;\n\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n\n  var spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\n\n\nfunction sortRankedItems(a, b) {\n  var aFirst = -1;\n  var bFirst = 1;\n  var aRankedItem = a.rankedItem,\n      aRank = a.rank,\n      aKeyIndex = a.keyIndex;\n  var bRankedItem = b.rankedItem,\n      bRank = b.rank,\n      bKeyIndex = b.keyIndex;\n\n  if (aRank === bRank) {\n    if (aKeyIndex === bKeyIndex) {\n      // localeCompare returns 0 if both values are equal,\n      // so we rely on JS engines stably sorting the results\n      // (de facto, all modern engine do this).\n      return String(aRankedItem).localeCompare(bRankedItem);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\n\n\nfunction prepareValueForComparison(value, _ref4) {\n  var keepDiacritics = _ref4.keepDiacritics;\n  value = \"\" + value; // toString\n\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n\n  return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\n\n\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n\n  var value;\n\n  if (typeof key === 'function') {\n    value = key(item); // eslint-disable-next-line no-negated-condition\n  } else if (key.indexOf('.') !== -1) {\n    // handle nested keys\n    value = key.split('.').reduce(function (itemObj, nestedKey) {\n      return itemObj ? itemObj[nestedKey] : null;\n    }, item);\n  } else {\n    value = item[key];\n  } // concat because `value` can be a string or an array\n  // eslint-disable-next-line\n\n\n  return value != null ? [].concat(value) : null;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param {Object} item - the item from which the values will be retrieved\n * @param {Array} keys - the keys to use to retrieve the values\n * @return {Array} objects with {itemValue, attributes}\n */\n\n\nfunction getAllValuesToRank(item, keys) {\n  return keys.reduce(function (allVals, key) {\n    var values = getItemValues(item, key);\n\n    if (values) {\n      values.forEach(function (itemValue) {\n        allVals.push({\n          itemValue: itemValue,\n          attributes: getKeyAttributes(key)\n        });\n      });\n    }\n\n    return allVals;\n  }, []);\n}\n/**\n * Gets all the attributes for the given key\n * @param {Object|String} key - the key from which the attributes will be retrieved\n * @return {Object} object containing the key's attributes\n */\n\n\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    key = {\n      key: key\n    };\n  }\n\n  return _extends({\n    maxRanking: Infinity,\n    minRanking: -Infinity\n  }, key);\n}\n\nexport default matchSorter;\nexport { rankings };","map":{"version":3,"sources":["/home/bridge/Petshop-web-app/petshopApp/frontend/node_modules/match-sorter/dist/match-sorter.esm.js"],"names":["_extends","removeAccents","rankings","CASE_SENSITIVE_EQUAL","EQUAL","STARTS_WITH","WORD_STARTS_WITH","STRING_CASE","STRING_CASE_ACRONYM","CONTAINS","ACRONYM","MATCHES","NO_MATCH","caseRankings","CAMEL","PASCAL","KEBAB","SNAKE","NO_CASE","matchSorter","items","value","options","_options","keys","_options$threshold","threshold","matchedItems","reduce","reduceItemsToRanked","sort","sortRankedItems","map","_ref","item","matches","index","_getHighestRanking","getHighestRanking","rankedItem","rank","keyIndex","_getHighestRanking$ke","keyThreshold","push","getMatchRanking","valuesToRank","getAllValuesToRank","_ref2","_ref3","i","itemValue","attributes","newRank","newRankedItem","minRanking","maxRanking","testString","stringToRank","prepareValueForComparison","length","caseRank","getCaseRanking","isPartial","isPartialOfCase","isCasedAcronym","isCaseAcronym","toLowerCase","indexOf","getAcronym","getClosenessRanking","string","acronym","wordsInString","split","forEach","wordInString","splitByHyphenWords","splitByHyphenWord","substr","containsUpperCase","containsDash","containsUnderscore","startsWithUpperCase","toUpperCase","caseRanking","testIndex","splitValue","splitTestString","correct","char","charIndex","splitItem","matchingInOrderCharCount","charNumber","findMatchingCharacter","matchChar","j","stringChar","getRanking","spread","inOrderPercentage","ranking","firstIndex","found","a","b","aFirst","bFirst","aRankedItem","aRank","aKeyIndex","bRankedItem","bRank","bKeyIndex","String","localeCompare","_ref4","keepDiacritics","getItemValues","key","itemObj","nestedKey","concat","allVals","values","getKeyAttributes","Infinity"],"mappings":"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","sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport removeAccents from 'remove-accents';\n\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 9,\n  EQUAL: 8,\n  STARTS_WITH: 7,\n  WORD_STARTS_WITH: 6,\n  STRING_CASE: 5,\n  STRING_CASE_ACRONYM: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nvar caseRankings = {\n  CAMEL: 0.8,\n  PASCAL: 0.6,\n  KEBAB: 0.4,\n  SNAKE: 0.2,\n  NO_CASE: 0\n};\nmatchSorter.rankings = rankings;\nmatchSorter.caseRankings = caseRankings;\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\n\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // not performing any search/sort if value(search term) is empty\n  if (!value) return items;\n  var _options = options,\n      keys = _options.keys,\n      _options$threshold = _options.threshold,\n      threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold;\n  var matchedItems = items.reduce(reduceItemsToRanked, []);\n  return matchedItems.sort(sortRankedItems).map(function (_ref) {\n    var item = _ref.item;\n    return item;\n  });\n\n  function reduceItemsToRanked(matches, item, index) {\n    var _getHighestRanking = getHighestRanking(item, keys, value, options),\n        rankedItem = _getHighestRanking.rankedItem,\n        rank = _getHighestRanking.rank,\n        keyIndex = _getHighestRanking.keyIndex,\n        _getHighestRanking$ke = _getHighestRanking.keyThreshold,\n        keyThreshold = _getHighestRanking$ke === void 0 ? threshold : _getHighestRanking$ke;\n\n    if (rank >= keyThreshold) {\n      matches.push({\n        rankedItem: rankedItem,\n        item: item,\n        rank: rank,\n        index: index,\n        keyIndex: keyIndex\n      });\n    }\n\n    return matches;\n  }\n}\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\n\n\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedItem: item,\n      rank: getMatchRanking(item, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n\n  var valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce(function (_ref2, _ref3, i) {\n    var rank = _ref2.rank,\n        rankedItem = _ref2.rankedItem,\n        keyIndex = _ref2.keyIndex,\n        keyThreshold = _ref2.keyThreshold;\n    var itemValue = _ref3.itemValue,\n        attributes = _ref3.attributes;\n    var newRank = getMatchRanking(itemValue, value, options);\n    var newRankedItem = rankedItem;\n    var minRanking = attributes.minRanking,\n        maxRanking = attributes.maxRanking,\n        threshold = attributes.threshold;\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedItem = itemValue;\n    }\n\n    return {\n      rankedItem: newRankedItem,\n      rank: rank,\n      keyIndex: keyIndex,\n      keyThreshold: keyThreshold\n    };\n  }, {\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\n\n\nfunction getMatchRanking(testString, stringToRank, options) {\n  /* eslint complexity:[2, 12] */\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options); // too long\n\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  } // case sensitive equals\n\n\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  }\n\n  var caseRank = getCaseRanking(testString);\n  var isPartial = isPartialOfCase(testString, stringToRank, caseRank);\n  var isCasedAcronym = isCaseAcronym(testString, stringToRank, caseRank); // Lower casing before further comparison\n\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase(); // case insensitive equals\n\n  if (testString === stringToRank) {\n    return rankings.EQUAL + caseRank;\n  } // starts with\n\n\n  if (testString.indexOf(stringToRank) === 0) {\n    return rankings.STARTS_WITH + caseRank;\n  } // word starts with\n\n\n  if (testString.indexOf(\" \" + stringToRank) !== -1) {\n    return rankings.WORD_STARTS_WITH + caseRank;\n  } // is a part inside a cased string\n\n\n  if (isPartial) {\n    return rankings.STRING_CASE + caseRank;\n  } // is acronym for a cased string\n\n\n  if (caseRank > 0 && isCasedAcronym) {\n    return rankings.STRING_CASE_ACRONYM + caseRank;\n  } // contains\n\n\n  if (testString.indexOf(stringToRank) !== -1) {\n    return rankings.CONTAINS + caseRank;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  } // acronym\n\n\n  if (getAcronym(testString).indexOf(stringToRank) !== -1) {\n    return rankings.ACRONYM + caseRank;\n  } // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n\n\n  return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\n\n\nfunction getAcronym(string) {\n  var acronym = '';\n  var wordsInString = string.split(' ');\n  wordsInString.forEach(function (wordInString) {\n    var splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(function (splitByHyphenWord) {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n/**\n * Returns a score base on the case of the testString\n * @param {String} testString - the string to test against\n * @returns {Number} the number of the ranking,\n * based on the case between 0 and 1 for how the testString matches the case\n */\n\n\nfunction getCaseRanking(testString) {\n  var containsUpperCase = testString.toLowerCase() !== testString;\n  var containsDash = testString.indexOf('-') >= 0;\n  var containsUnderscore = testString.indexOf('_') >= 0;\n\n  if (!containsUpperCase && !containsUnderscore && containsDash) {\n    return caseRankings.KEBAB;\n  }\n\n  if (!containsUpperCase && containsUnderscore && !containsDash) {\n    return caseRankings.SNAKE;\n  }\n\n  if (containsUpperCase && !containsDash && !containsUnderscore) {\n    var startsWithUpperCase = testString[0].toUpperCase() === testString[0];\n\n    if (startsWithUpperCase) {\n      return caseRankings.PASCAL;\n    }\n\n    return caseRankings.CAMEL;\n  }\n\n  return caseRankings.NO_CASE;\n}\n/**\n * Returns whether the stringToRank is one of the case parts in the testString (works with any string case)\n * @example\n * // returns true\n * isPartialOfCase('helloWorld', 'world', caseRankings.CAMEL)\n * @example\n * // returns false\n * isPartialOfCase('helloWorld', 'oworl', caseRankings.CAMEL)\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Number} caseRanking - the ranking score based on case of testString\n * @returns {Boolean} whether the stringToRank is one of the case parts in the testString\n */\n\n\nfunction isPartialOfCase(testString, stringToRank, caseRanking) {\n  var testIndex = testString.toLowerCase().indexOf(stringToRank.toLowerCase());\n\n  switch (caseRanking) {\n    case caseRankings.SNAKE:\n      return testString[testIndex - 1] === '_';\n\n    case caseRankings.KEBAB:\n      return testString[testIndex - 1] === '-';\n\n    case caseRankings.PASCAL:\n    case caseRankings.CAMEL:\n      return testIndex !== -1 && testString[testIndex] === testString[testIndex].toUpperCase();\n\n    default:\n      return false;\n  }\n}\n/**\n * Check if stringToRank is an acronym for a partial case\n * @example\n * // returns true\n * isCaseAcronym('super_duper_file', 'sdf', caseRankings.SNAKE)\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the acronym to test\n * @param {Number} caseRank - the ranking of the case\n * @returns {Boolean} whether the stringToRank is an acronym for the testString\n */\n\n\nfunction isCaseAcronym(testString, stringToRank, caseRank) {\n  var splitValue = null;\n\n  switch (caseRank) {\n    case caseRankings.SNAKE:\n      splitValue = '_';\n      break;\n\n    case caseRankings.KEBAB:\n      splitValue = '-';\n      break;\n\n    case caseRankings.PASCAL:\n    case caseRankings.CAMEL:\n      splitValue = /(?=[A-Z])/;\n      break;\n\n    default:\n      splitValue = null;\n  }\n\n  var splitTestString = testString.split(splitValue);\n  return stringToRank.toLowerCase().split('').reduce(function (correct, char, charIndex) {\n    var splitItem = splitTestString[charIndex];\n    return correct && splitItem && splitItem[0].toLowerCase() === char;\n  }, true);\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\n\n\nfunction getClosenessRanking(testString, stringToRank) {\n  var matchingInOrderCharCount = 0;\n  var charNumber = 0;\n\n  function findMatchingCharacter(matchChar, string, index) {\n    for (var j = index; j < string.length; j++) {\n      var stringChar = string[j];\n\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n\n    return -1;\n  }\n\n  function getRanking(spread) {\n    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    var ranking = rankings.MATCHES + inOrderPercentage * (1 / spread);\n    return ranking;\n  }\n\n  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n\n  charNumber = firstIndex;\n\n  for (var i = 1; i < stringToRank.length; i++) {\n    var matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    var found = charNumber > -1;\n\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n\n  var spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\n\n\nfunction sortRankedItems(a, b) {\n  var aFirst = -1;\n  var bFirst = 1;\n  var aRankedItem = a.rankedItem,\n      aRank = a.rank,\n      aKeyIndex = a.keyIndex;\n  var bRankedItem = b.rankedItem,\n      bRank = b.rank,\n      bKeyIndex = b.keyIndex;\n\n  if (aRank === bRank) {\n    if (aKeyIndex === bKeyIndex) {\n      // localeCompare returns 0 if both values are equal,\n      // so we rely on JS engines stably sorting the results\n      // (de facto, all modern engine do this).\n      return String(aRankedItem).localeCompare(bRankedItem);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\n\n\nfunction prepareValueForComparison(value, _ref4) {\n  var keepDiacritics = _ref4.keepDiacritics;\n  value = \"\" + value; // toString\n\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n\n  return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\n\n\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n\n  var value;\n\n  if (typeof key === 'function') {\n    value = key(item); // eslint-disable-next-line no-negated-condition\n  } else if (key.indexOf('.') !== -1) {\n    // handle nested keys\n    value = key.split('.').reduce(function (itemObj, nestedKey) {\n      return itemObj ? itemObj[nestedKey] : null;\n    }, item);\n  } else {\n    value = item[key];\n  } // concat because `value` can be a string or an array\n  // eslint-disable-next-line\n\n\n  return value != null ? [].concat(value) : null;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param {Object} item - the item from which the values will be retrieved\n * @param {Array} keys - the keys to use to retrieve the values\n * @return {Array} objects with {itemValue, attributes}\n */\n\n\nfunction getAllValuesToRank(item, keys) {\n  return keys.reduce(function (allVals, key) {\n    var values = getItemValues(item, key);\n\n    if (values) {\n      values.forEach(function (itemValue) {\n        allVals.push({\n          itemValue: itemValue,\n          attributes: getKeyAttributes(key)\n        });\n      });\n    }\n\n    return allVals;\n  }, []);\n}\n/**\n * Gets all the attributes for the given key\n * @param {Object|String} key - the key from which the attributes will be retrieved\n * @return {Object} object containing the key's attributes\n */\n\n\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    key = {\n      key: key\n    };\n  }\n\n  return _extends({\n    maxRanking: Infinity,\n    minRanking: -Infinity\n  }, key);\n}\n\nexport default matchSorter;\nexport { rankings };\n"]},"metadata":{},"sourceType":"module"}